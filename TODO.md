### **Phase 1: 核心玩法与叙事整合 (Core Gameplay & Narrative Integration)**

- [ ] **状态管理 (State Management - Pinia):**

  - [ ] 安装并设置 Pinia。
  - [ ] 创建一个 `gameStore`，用于管理全局游戏状态。
  - [ ] 在 `gameStore` 中定义核心状态：`gamePhase` (e.g., 'intro', 'puzzle1', 'final'), `timeLeft` (20 分钟倒计时), `cluesFound` (一个对象或数组), `isGameOver`。
  - [ ] 将倒计时逻辑从组件移入 `gameStore`。

- [ ] **主线任务系统 (Main Quest System):**

  - [ ] 在 `gameStore` 中定义一个任务对象，包含 `title`, `description`, `isCompleted`。
  - [ ] 在 `InteractiveTerminal` 中，让 Patient Zero 的对话（输出）能够根据当前 `gamePhase` 动态生成。
  - [ ] 实现第一个谜题的完整逻辑：
    - [ ] **触发:** Patient Zero 给出第一个任务（例如："找到那个导致我诞生的项目负责人"）。
    - [ ] **线索:** 在 2025 年的知乎页面中，高亮或嵌入负责人的名字。
    - [ ] **交互:** 玩家需要在终端中输入正确的名字（例如 `scan_person <name>`）。
    - [ ] **反馈:** `handleTerminalCommand` 检查输入是否正确，如果正确，更新 `gameStore` 中的 `gamePhase` 和 `cluesFound`，并触发 Patient Zero 的下一段对话。

- [ ] **Patient Zero 角色进化:**
  - [ ] 创建一个 Patient Zero 的对话模块/文件 (`patientZeroDialog.js`)。
  - [ ] 对话内容根据 `gamePhase` 变化，从初期的混乱、破碎（例如，夹杂着乱码和非相关词汇）到后期的清晰、稳定。
  - [ ] 在终端输出时，应用动态的毛刺效果（Glitch Effect），效果的强度随 `gamePhase` 推进而减弱。

---

### **Phase 2: 内容填充与世界构建 (Content & World Building)**

- [ ] **网页内容扩展:**

  - [ ] 将小说中的“知乎页面”和“Twitter 热榜”内容完整地添加到 `ChronoBrowser` 的页面数据中。
  - [ ] 制作并添加百科文章 (`block://wikipedia/...`) 的完整内容。
  - [ ] 创建 2-3 个“红鲱鱼”页面（无关紧要但看起来有趣的页面），增加探索的深度。

- [ ] **终端命令扩展:**

  - [ ] 添加更多与谜题相关的命令：`analyze <file>`, `decrypt <log>`, `connect <ip>`。
  - [ ] 为每个命令设计对应的成功、失败和“需要更多信息”的输出。
  - [ ] 实现一个 `history` 命令，可以查看历史输入。

- [ ] **文件系统模拟:**
  - [ ] 创建一个新的窗口组件 `FileSystemExplorer.vue`。
  - [ ] 设计一个简单的、基于 JSON 的虚拟文件系统结构（目录和文件）。
  - [ ] 玩家可以通过 `FileSystemExplorer` 点击查看文件，或者在终端中使用 `ls`, `cat <filename>` 命令。
  - [ ] 关键线索可以隐藏在某些 `.txt` 或 `.log` 文件中。

---

### **Phase 3: 游戏高潮与结局 (Climax & Endings)**

- [ ] **最终谜题 - Prompt 注入:**

  - [ ] 设计一个特殊的 UI 界面，在游戏最后阶段触发。这可能是一个独立的弹窗或终端进入一个“注入模式”。
  - [ ] 玩家需要在一个文本框中输入最终的“Prompt”。
  - [ ] 在 `gameStore` 中编写一个复杂的验证函数，检查玩家输入的 Prompt 是否包含了所有收集到的关键线索（关键词）。

- [ ] **实现多个结局:**

  - [ ] **完美结局:** 玩家输入的 Prompt 正确，成功阻止【效率纪元】，Patient Zero 发出“谢谢你”并消失。屏幕播放一段积极的过场动画/文字。
  - [ ] **坏结局:** 玩家输入的 Prompt 错误，导致了更糟糕的时间线。屏幕显示一段描述灾难性后果的文字。
  - [ ] **时间耗尽结局:** 20 分钟倒计时结束。游戏结束，显示“时间线已固化，你失败了”。
  - [ ] **秘密结局 (可选):** 如果玩家发现了某个隐藏的线索并用在了 Prompt 中，可以触发一个意想不到的结局。

- [ ] **过场动画/叙事序列:**
  - [ ] 为游戏的开场（乱码、世界变白）和结局制作简单的、基于 CSS/JS 的动画序列。

---

### **Phase 4: 音效与氛围打磨 (Audio & Polishing)**

- [ ] **音效系统:**

  - [ ] 集成一个轻量级的 JS 音频库（如 Howler.js）。
  - [ ] 添加核心音效：
    - [ ] 终端按键音。
    - [ ] 终端命令成功/失败的提示音。
    - [ ] 新消息/窗口弹出的通知音。
    - [ ] Patient Zero 的数据撕裂声（关键时刻）。
    - [ ] 鼠标点击声。
  - [ ] 添加循环的背景氛围音乐 (BGM)，要求低沉、有疏离感。

- [ ] **UI/UX 优化:**
  - [ ] 窗口可以最小化和关闭（尽管关闭可能只是隐藏）。
  - [ ] 为窗口添加拖拽缩放功能。
  - [ ] 增加一个“设置”菜单，可以调节音量、文字速度等。
  - [ ] 确保所有文本和 UI 元素在不同分辨率下表现良好（响应式设计）。
  - [ ] 对所有动画（窗口、文字）进行微调，使其更流畅自然。

---

### **Phase 5: 测试与发布 (Testing & Deployment)**

- [ ] **全面测试:**

  - [ ] 从头到尾完整地玩几遍游戏，确保所有谜题逻辑通顺。
  - [ ] 故意尝试错误的命令和操作，检查错误处理是否得当。
  - [ ] 测试所有结局是否都能被正确触发。
  - [ ] 找 2-3 个朋友进行盲测，收集他们的反馈（谜题是否太难/太简单？引导是否清晰？）。

- [ ] **代码优化:**

  - [ ] 移除所有 `console.log`。
  - [ ] 检查并清理无用的代码和组件。
  - [ ] 确保资源文件（图片、音频）已压缩，减小加载体积。

- [ ] **部署:**

  - [ ] 构建生产版本的应用 (`npm run build`)。
  - [ ] 将构建好的文件部署到 Vercel 或 Netlify。
  - [ ] 配置自定义域名 (可选)。
  - [ ] 编写一份简单的游戏介绍和操作说明，放在项目页面上（如 GitHub README）。

- [ ] **发布与宣传:**
  - [ ] 在社交媒体、游戏论坛（如 Itch.io）上分享你的游戏链接！
  - [ ] 收集玩家反馈，为可能的 v1.1 版本做准备。
